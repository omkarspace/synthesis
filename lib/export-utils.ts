import jsPDF from 'jspdf';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';

interface PaperContent {
    title: string;
    abstract?: string;
    introduction?: string;
    literatureReview?: string;
    methodology?: string;
    results?: string;
    discussion?: string;
    conclusion?: string;
    references?: string[];
    fullText?: string;
}

/**
 * Export paper as PDF
 */
export async function exportToPDF(paper: PaperContent, filename: string = 'research-paper'): Promise<Blob> {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    const maxWidth = pageWidth - 2 * margin;
    let yPosition = 20;

    // Helper to add text with wrapping
    const addText = (text: string, fontSize: number = 12, isBold: boolean = false) => {
        doc.setFontSize(fontSize);
        if (isBold) {
            doc.setFont('helvetica', 'bold');
        } else {
            doc.setFont('helvetica', 'normal');
        }

        const lines = doc.splitTextToSize(text, maxWidth);
        lines.forEach((line: string) => {
            if (yPosition > 280) {
                doc.addPage();
                yPosition = 20;
            }
            doc.text(line, margin, yPosition);
            yPosition += fontSize * 0.5;
        });
        yPosition += 5;
    };

    // Title
    addText(paper.title, 18, true);
    yPosition += 10;

    // Abstract
    if (paper.abstract) {
        addText('Abstract', 14, true);
        addText(paper.abstract);
        yPosition += 10;
    }

    // Sections
    const sections = [
        { title: 'Introduction', content: paper.introduction },
        { title: 'Literature Review', content: paper.literatureReview },
        { title: 'Methodology', content: paper.methodology },
        { title: 'Results', content: paper.results },
        { title: 'Discussion', content: paper.discussion },
        { title: 'Conclusion', content: paper.conclusion },
    ];

    sections.forEach(section => {
        if (section.content) {
            addText(section.title, 14, true);
            addText(section.content);
            yPosition += 10;
        }
    });

    // References
    if (paper.references && paper.references.length > 0) {
        addText('References', 14, true);
        paper.references.forEach((ref, idx) => {
            addText(`[${idx + 1}] ${ref}`, 10);
        });
    }

    return doc.output('blob');
}

/**
 * Export paper as LaTeX
 */
export function exportToLaTeX(paper: PaperContent): string {
    let latex = `\\documentclass{article}
\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage{graphicx}
\\usepackage{hyperref}

\\title{${escapeLatex(paper.title)}}
\\author{Generated by AI Research App}
\\date{\\today}

\\begin{document}

\\maketitle

`;

    if (paper.abstract) {
        latex += `\\begin{abstract}
${escapeLatex(paper.abstract)}
\\end{abstract}

`;
    }

    const sections = [
        { title: 'Introduction', content: paper.introduction },
        { title: 'Literature Review', content: paper.literatureReview },
        { title: 'Methodology', content: paper.methodology },
        { title: 'Results', content: paper.results },
        { title: 'Discussion', content: paper.discussion },
        { title: 'Conclusion', content: paper.conclusion },
    ];

    sections.forEach(section => {
        if (section.content) {
            latex += `\\section{${section.title}}
${escapeLatex(section.content)}

`;
        }
    });

    if (paper.references && paper.references.length > 0) {
        latex += `\\begin{thebibliography}{99}
`;
        paper.references.forEach((ref, idx) => {
            latex += `\\bibitem{ref${idx + 1}} ${escapeLatex(ref)}
`;
        });
        latex += `\\end{thebibliography}

`;
    }

    latex += `\\end{document}`;

    return latex;
}

/**
 * Export paper as DOCX
 */
export async function exportToDOCX(paper: PaperContent): Promise<Blob> {
    const children: Paragraph[] = [];

    // Title
    children.push(
        new Paragraph({
            text: paper.title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 }
        })
    );

    // Abstract
    if (paper.abstract) {
        children.push(
            new Paragraph({
                text: 'Abstract',
                heading: HeadingLevel.HEADING_1,
                spacing: { before: 200, after: 200 }
            }),
            new Paragraph({
                text: paper.abstract,
                spacing: { after: 400 }
            })
        );
    }

    // Sections
    const sections = [
        { title: 'Introduction', content: paper.introduction },
        { title: 'Literature Review', content: paper.literatureReview },
        { title: 'Methodology', content: paper.methodology },
        { title: 'Results', content: paper.results },
        { title: 'Discussion', content: paper.discussion },
        { title: 'Conclusion', content: paper.conclusion },
    ];

    sections.forEach(section => {
        if (section.content) {
            children.push(
                new Paragraph({
                    text: section.title,
                    heading: HeadingLevel.HEADING_1,
                    spacing: { before: 200, after: 200 }
                }),
                new Paragraph({
                    text: section.content,
                    spacing: { after: 200 }
                })
            );
        }
    });

    // References
    if (paper.references && paper.references.length > 0) {
        children.push(
            new Paragraph({
                text: 'References',
                heading: HeadingLevel.HEADING_1,
                spacing: { before: 200, after: 200 }
            })
        );

        paper.references.forEach((ref, idx) => {
            children.push(
                new Paragraph({
                    text: `[${idx + 1}] ${ref}`,
                    spacing: { after: 100 }
                })
            );
        });
    }

    const doc = new Document({
        sections: [{
            properties: {},
            children: children
        }]
    });

    return await Packer.toBlob(doc);
}

/**
 * Export paper as Markdown
 */
export function exportToMarkdown(paper: PaperContent): string {
    let markdown = `# ${paper.title}\n\n`;

    if (paper.abstract) {
        markdown += `## Abstract\n\n${paper.abstract}\n\n`;
    }

    const sections = [
        { title: 'Introduction', content: paper.introduction },
        { title: 'Literature Review', content: paper.literatureReview },
        { title: 'Methodology', content: paper.methodology },
        { title: 'Results', content: paper.results },
        { title: 'Discussion', content: paper.discussion },
        { title: 'Conclusion', content: paper.conclusion },
    ];

    sections.forEach(section => {
        if (section.content) {
            markdown += `## ${section.title}\n\n${section.content}\n\n`;
        }
    });

    if (paper.references && paper.references.length > 0) {
        markdown += `## References\n\n`;
        paper.references.forEach((ref, idx) => {
            markdown += `${idx + 1}. ${ref}\n`;
        });
    }

    return markdown;
}

/**
 * Helper function to escape LaTeX special characters
 */
function escapeLatex(text: string): string {
    return text
        .replace(/\\/g, '\\textbackslash{}')
        .replace(/[&%$#_{}]/g, '\\$&')
        .replace(/~/g, '\\textasciitilde{}')
        .replace(/\^/g, '\\textasciicircum{}');
}
